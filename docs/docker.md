# [Docker Build Plugin](src/main/scala/org/allenai/plugins/DockerBuildPlugin.scala)

This plugin provides integration with [Docker Engine](https://docs.docker.com/engine/installation/). It helps you generate Dockerfiles, build images, run images, and push images to a Docker registry.

The intent is to provide a very simple interaction with Docker, without needing to understand low-level details around how Docker works. However, default behavior is easy to override, as documented below.

This plugin requires you have access to the `docker` command in your shell.  See the [Docker install page](https://www.docker.com/products/overview#/install_the_platform) for installation instructions.

## Table of Contents

* [Basic Workflow](#workflow)
  * [How the project image is built](#how-the-project-image-is-built)
  * [The start script](#the-start-script)
  * [Generating the Dockerfile](#generating-the-dockerfile)
* [Common Commands](#common-commands)
  * [generateDockerfile](#generatedockerfile)
  * [dockerBuild](#dockerbuild)
  * [dockerRun and dockerStop](#dockerrun-and-dockerstop)
  * [dockerPush](#dockerpush)
* [Other Commands](#other-commands)
  * [dockerMainStage and dockerDependencyStage](#dockermainstage-and-dockerdependencystage)
  * [dockerDependencyBuild](#dockerdependencybuild)
* [Settings](#settings)

## Workflow

Enable the plugin for your project:
```scala
lazy val myProject = Project(id = "myProject", base = file("."))
  // Add the below!
  .enablePlugins(DockerBuildPlugin)
```

If you don't have a [Dockerfile](https://docs.docker.com/engine/reference/builder/):

0. Generate a Dockerfile for your project. This can be done automatically with the [generateDockerfile](#generatedockerfile) task. This should be checked in to source control along with the rest of your source code.

Once you have a Dockerfile:

1. Run [dockerBuild](#dockerbuild) to build your image.
2. Run [dockerRun](#dockerrun) to run your image in a container locally.
3. Run [dockerPush](#dockerpush) to push your image to a registry.

### How the project image is built

The project image itself is made up of a two-image composite: A dependency image, with your external (i.e. Maven) dependencies, and a main image, with all of your locally-built jars and configuration files. The Dockerfile generated by the plugin and checked into source control is for the second of these two images, and should use the dependency image as its base.

The dependency image has a very simple Dockerfile:
```dockerfile
FROM ${dockerImageBase.value}
WORKDIR ${dockerWorkdir.value}
STOPSIGNAL SIGINT
COPY bin bin
COPY lib lib
```
The base image defaults to `allenai-docker-private-docker.bintray.io/oracle-java:8`, and the workdir defaults to `/stage`. `bin` is copied in order to capture [the start script](#the-start-script), while `lib` contains all of the dependency jars. Finally, this configures the default stop signal for your docker container (the default SIGTERM is ignored by the JVM).

The main image has a more complicated Dockerfile template. The best way to get acquainted with it is to generate one and read through it, or to browse [the settings section below](#settings). The chief point of interest is that it uses a `FROM` to inherit from the dependency image.

Layering the two images like this has a huge advantage: When rebuilding an image to take into account the changes you've made to code locally, you don't need to copy all of the dependency jars into the docker daemon if your dependencies are unchanged. This shaves several seconds off of rebuild time.

Note that the plugin will detect when image contents have changed, and will only run the underlying `docker build` command when they do.

### The start script

Part of the underlying dependency image is a start script, located in `bin/run-docker.sh`. This is a direct copy of [this script in `src/main/resources`](src/main/resources/org/allenai/plugins/run-docker.sh). The script is a simple bash script that will start up a `java` process using all of the jars in `lib` as its classpath, and is used as the ENTRYPOINT for the main image.

It uses the following environment variables for configuration:

- `JAVA_MAIN` (required): - The main class to execute.
- `JVM_ARGS` - Arguments to pass to the `java` process, before the class name. If unset, defaults to
               `"-Xms512m -Xmx512m"`.
- `CONFIG_ENV` - Controls which Typesafe config is used in the application. The file
                 `conf/${CONFIG_ENV}.conf` will be used if it exists; else, `conf/application.conf`
                 will be used if it exists.

Note that you can set environment variables for a docker run by using the `-e` flag.

Additionally, the script will:
* Change the working drectory to `bin/..`
* Set the Java system property `logback.configurationFile` to `conf/logback.xml`, if that file
  exists
* Set the Java system property `application.cacheKey` to the contents of `conf/cacheKey.sha1`, if
  that file exists

### Generating the Dockerfile

The `generateDockerfile` task will create a Dockerfile for at the location
pointed to by the [`dockerfileLocation`](#dockerfilelocation) setting. Note that this Dockerfile is for the main project image - see the above section [How the project image is built](#how-the-project-image-is-built) for more information on exactly what that means.

The file will be generated using your current project's settings. See [the task description below](#generatedockerfile) for full details. In the file, you'll see example sbt settings in comments above the lines that the settings produced. If you wish to update the file, you can copy and paste these settings into your sbt project, make the changes you want, reload sbt, and re-run `generateDockerfile`.

The generated file also includes a special sigil line, comprised of a sequence of `#+#+` characters. Any text below this line will be retained in the generated file, allowing you to further customize your Dockerfile beyond the simple customization provided through sbt settings.

## Common Commands

These are commands that are meant to be run as a part of most basic workflows.

### generateDockerfile

This task creates a main image Dockerfile for your project based on the current project settings.
If a Dockerfile already exists, any content in the file after the sigil line (a 100-character series
of #+ symbols) will be retained.

The following settings influence the generation of this file:

[`dockerfileLocation`](#dockerfilelocation) - The location the dockerfile will be generated.

[`dockerImageBase`](#dockerimagebase) - The base image to use for the dependency image.

[`dockerImageRegistryHost`](#dockerimageregistryhost), [`dockerImageNamePrefix`](#dockerimagenameprefix), and [`dockerImageName`](#dockerimagename) - The three settings used to generate the name of the image that is created.

[`dockerCopyMappings`](#dockercopymappings) - File mappings to include in the stage directory and built image.

`javaOptions` - The value for the `JVM_ARGS` environment variable used by the startup script. This is a core sbt setting.

`mainClass` - The value for the `JAVA_MAIN` environment variable used by the startup script. This is a core sbt setting. Note that `generateDockerfile` will emit a warning if you run it while this setting is unset.

[`dockerMainArgs`](#dockermainargs) - The value to use for CMD. This functions as default arguments to your application if none are provided to `docker run`.

[`dockerPorts`](#dockerports) - The ports to EXPOSE in your Dockerfile. This also influences the default ports which are mapped when using `dockerRun`. See [`dockerPortMappings`](#dockerportmappings).

[`dockerWorkdir`](#dockerworkdir) - The value to use for WORKDIR.

### dockerBuild

This task builds two docker images, as described in [How the project image is built](#how-the-project-image-is-built). The main image will be constructed using the Dockerfile located at the location pointed to by [`dockerfileLocation`](#dockerfilelocation). If this file doesn't exist, an error will be raised.

Both of the images created are tagged with two tags: The default tag `latest`, and a SHA-1 hash of their contents. After the images are created with the two tags, the previous image will have the SHA-1 tag removed. This will delete the image from the local Docker registry if it hasn't had another tag manually added.

**Note**: Image cleanup will occasionally fail, notably if an `sbt clean` is run, since that wipes out the record of the previous image's content hash. If that occurs, you will need to remove the image manually. There is a work item pending to make an cleanup task to do this automatically.

### dockerRun and dockerStop

These tasks are used to run an image after building it. `dockerRun` will first run `dockerBuild`, then stop any running docker container for the current project, then start a new container running the new image. Containers are run using the `--rm` flag, so they'll be cleaned up automatically on exit. `dockerStop` will stop any currently-running container for the current project.

`dockerRun` also perform one other tiny trick: Before stopping the container, the container will get renamed. This prevents name collisions due to a race condition in the docker client: A `docker stop` command will complete before the container is completely cleaned up, and the subsequent `docker run` will produce an error if it happens too quickly.

### dockerPush

This task accepts any number of string arguments.

If no arguments are provided, this will push the main image tagged with the SHA-1 tag.

If arguments are provided, this will push the main image tagged with all of the given tags. Missing tags will be added to the image before pushing.

## Other Commands

These are commands that might be used in custom workflows, but won't normally be invoked on their
own.

### dockerMainStage and dockerDependencyStage

These two tasks run only the staging step of the docker build. They create the directories that will be included in the docker image, including the Dockerfiles. `dockerMainStage` creates its staging directory at `target/docker/main`, while `dockerDependencyStage` creates its at `target/docker/dependencies`.

These tasks are provided for users who wish to have more control over what goes in to the image directories, or who wish to populate the directories from outside of sbt.

### dockerDependencyBuild

This task builds only the dependency image, after staging it. It's primarily useful for debugging.

## Settings

### dockerfileLocation
Value type: File

The location of the Dockerfile to use when generating Dockerfiles or building the main project
image. Defaults to `srcDirectory.value + "docker/Dockerfile"`, typically `src/main/docker/Dockerfile`.

### dockerImageBase
Value type: String

The image to use as the base image for the dependency image (what is on the dependency image's FROM line). Defaults to `allenai-docker-private-docker.bintray.io/oracle-java:8`.

### dockerImageRegistryHost
Value type: String

The registry host to use when generating your image names. Defaults to
`allenai-docker-private-docker.bintray.io`.

The final image names will be:
```scala
val mainImageName = s"${dockerImageRegistryHost.value}/${dockerImageNamePrefix.value}/${dockerImageName.value}"
val dependencyImageName = s"$mainImageName-dependency"
```

### dockerImageNamePrefix
Value type: String

The image name prefix ("repository", in Docker terms) of the main image.  Defaults to
`organization.value.stripPrefix("org.allenai.")`. This is typically the github repository name.

The final image names will be:
```scala
val mainImageName = s"${dockerImageRegistryHost.value}/${dockerImageNamePrefix.value}/${dockerImageName.value}"
val dependencyImageName = s"$mainImageName-dependency"
```

### dockerImageName
Value type: String

The name of the image you're creating. Defaults to `name.value` - the sbt project name.

The final image names will be:
```scala
val mainImageName = s"${dockerImageRegistryHost.value}/${dockerImageNamePrefix.value}/${dockerImageName.value}"
val dependencyImageName = s"$mainImageName-dependency"
```

### dockerCopyMappings
Value type: Seq[(File, String)]

Mappings to add to the Docker image. Relative file paths will be interpreted as being relative to
the project base directory (`baseDirectory.value`). See
[Mapping Files](http://www.scala-sbt.org/0.12.3/docs/Detailed-Topics/Mapping-Files.html)
for detailed info on sbt mappings. Defaults to mapping just `src/main/resources` to `conf`.

### dockerPorts
Value type: Seq[Int]

The value(s) to use for EXPOSE when generating your Dockerfile. Defaults to `Seq.empty`.

### dockerPortMappings
Value type: Seq[(Int, Int)]

The port mapping(s) to use when running your docker image via `dockerRun`, as (hostPort,
containerPort) pairs. Defaults to mapping all of the values `dockerPorts.value` to
themselves (identity mapping).

### dockerMainArgs
Value type: Seq[String]

The value to use for CMD in your main image Dockerfile. These will be treated as default arguments to your binary. Defaults to `Seq.empty`.

### dockerWorkdir
Value type: String
The value to use for WORKDIR when generating your Dockerfile. Defaults to `"/stage"`.
